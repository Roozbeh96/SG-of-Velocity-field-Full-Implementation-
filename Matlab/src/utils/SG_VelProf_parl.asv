function [Gen_u_prof, Gen_w_prof, log_data] = SG_VelProf_parl(obj)
%SGVF generate step like velocity profiles. Detail of line will explain in
%the folllowing lines.
%#ok<*AGROW>
% --- Step 1: Pre-generate random numbers ---
    Nrand = 1e6;
    [rand_u, rand_w] = genGaussCop(obj.ro_uw, Nrand);
    rand_h = rand(Nrand,1);
    
    % --- Step 2: Preallocate outputs ---
    Gen_u_prof = zeros(size(obj.z,2), obj.N_prof);
    Gen_w_prof = zeros(size(obj.z,2), obj.N_prof);
    log_data   = cell(obj.N_prof,1);
    
    % --- Step 3: Setup chunks per profile ---
    % Compute chunk size per profile
    chunk_size = floor(Nrand / obj.N_prof);
    
    % --- Step 4: Parallel pool ---
    parpool('local', 4); % optional: start specific pool

parfor prof_num = 1:obj.N_prof
    % Each worker uses its own portion of random numbers
    idx1 = (prof_num-1)*chunk_size + 1;
    idx2 = min(prof_num*chunk_size, Nrand);

    local_rand_u = rand_u(idx1:idx2);
    local_rand_w = rand_w(idx1:idx2);
    local_rand_h = rand_h(idx1:idx2);

    counter_1 = 1;
    z_i = obj.z(1);
    z_ind = 1;
    counter_2 = 1;

    % local copy of profile arrays
    local_u = zeros(size(obj.z,2),1);
    local_w = zeros(size(obj.z,2),1);
    local_log = cell(1,1000); % preallocate rough size

    while z_i < obj.z(end)
        hm_i = z_i*exp(-3.59*(z_i/obj.delta)^0.91 + ...
                sqrt(2)*erfinv(2*local_rand_h(counter_1)-1));
        um_i = obj.u_tau*(1/0.39*log((z_i+hm_i/2)/obj.z_0) + ...
                2*sqrt(2)*erfinv(2*local_rand_u(counter_1)-1));
        wm_i = obj.u_tau*(0.85*sqrt(2)*erfinv(2*local_rand_w(counter_1)-1));

        row = find(obj.z > z_i + hm_i, 1, 'first');
        if isempty(row)
            row = length(obj.z) + 1;
        end

        local_u(z_ind:row-1) = um_i;
        local_w(z_ind:row-1) = wm_i;

        local_log{counter_2} = dictionary(["hm_i","zm_i","um_i","wm_i"], ...
            [hm_i, z_i+hm_i/2, um_i, wm_i]);

        z_i = min(z_i + hm_i, obj.z(end));
        z_ind = row;
        counter_2 = counter_2 + 1;
        counter_1 = counter_1 + 1;

        if counter_1 > numel(local_rand_u)
            error(['Not enough pre-generated random numbers for profile #%d. ' ...
                        'Please increase the number of generated random samples. ' ...
                        'Current limit: %d, required index: %d.'], ...
                        prof_num, numel(local_rand_u), counter_1);
        end
    end

    % Store results back safely (sliced assignment)
    Gen_u_prof(:, prof_num) = local_u;
    Gen_w_prof(:, prof_num) = local_w;
    log_data{prof_num} = local_log(1:counter_2-1);
end


end



function [Gen_u_prof, Gen_w_prof, log_data] = SG_VelProf_parl(obj)
%SGVF generate step like velocity profiles. Detail of line will explain in
%the folllowing lines.
%#ok<*AGROW>
    N_rand = 1e6;
    [rand_u,rand_w] = genGaussCop(obj.ro_uw, N_rand);
    Gen_u_prof = zeros(size(obj.z,2),obj.N_prof);
    Gen_w_prof = zeros(size(obj.z,2),obj.N_prof);
    kappa = 0.39;
    rng(37)
    rand_h = rand(N_rand,1);
    % parpool('local',4);
    counter_1 = 1;
        for prof_num = 1:obj.N_prof
            z_i = obj.z(1);
            z_ind = 1;
            counter_2 = 1;
            while z_i < obj.z(end)
                hm_i = z_i*exp(-3.59*(z_i/obj.delta)^0.91+1*sqrt(2)*erfinv(2*rand_h(counter_1)-1));
                um_i = obj.u_tau*(1/kappa*log((z_i+hm_i/2)/obj.z_0)+2*sqrt(2)*erfinv(2*rand_u(counter_1)-1));
                wm_i = obj.u_tau*(0+0.85*sqrt(2)*erfinv(2*rand_w(counter_1)-1));
        
                row = find(obj.z > z_i + hm_i,1,'first');
                if row
                    log_data{prof_num}{counter_2} = ...
                        dictionary(["hm_i","zm_i","um_i","wm_i"],...
                        [hm_i, z_i+hm_i/2, um_i, wm_i]);
                    Gen_u_prof(z_ind:row-1, prof_num) = um_i;
                    Gen_w_prof(z_ind:row-1, prof_num) = wm_i;
                    z_i = z_i + hm_i;
                else
                    log_data{prof_num}{counter_2} = ...
                        dictionary(["hm_i","zm_i","um_i","wm_i"],...
                        [obj.z(end)-z_i, 0.5*(z_i+obj.z(end)), um_i, wm_i]);
                    Gen_u_prof(z_ind:end, prof_num) = um_i;
                    Gen_w_prof(z_ind:end, prof_num) = wm_i;
                    z_i = obj.z(end);
                end
                z_ind = row;
                counter_2 = counter_2 + 1;
                counter_1 = counter_1 + 1;
                if counter_1 > numel(rand_u)
                    error(['Not enough pre-generated random numbers for profile #%d. ' ...
                        'Please increase the number of generated random samples. ' ...
                        'Current limit: %d, required index: %d.'], ...
                        prof_num, numel(rand_u), counter_1);
                end
            end
        
        end
end




